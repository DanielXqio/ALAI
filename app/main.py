"""FastAPI application exposing ggwave CLI helpers over HTTP."""

from __future__ import annotations

import os
import re
import subprocess
import tempfile
from pathlib import Path
from typing import Iterable

from fastapi import FastAPI, File, HTTPException, Query, UploadFile
from fastapi.responses import PlainTextResponse, StreamingResponse
from starlette.background import BackgroundTask

PROJECT_ROOT = Path(__file__).resolve().parent.parent
DEFAULT_ENCODE_PATH = PROJECT_ROOT / "external" / "ggwave" / "build" / "bin" / "ggwave-to-file"
FALLBACK_ENCODE_PATH = PROJECT_ROOT / "external" / "ggwave" / "build" / "bin" / "ggwave-cli"
DEFAULT_DECODE_PATH = PROJECT_ROOT / "external" / "ggwave" / "build" / "bin" / "ggwave-from-file"
DECODE_PATTERN = re.compile(r"Decoded message with length \d+: '([^']*)'")

app = FastAPI(
    title="ggwave HTTP bridge",
    description=(
        "Minimal API for encoding text into ultrasonic WAV payloads and decoding"
        " them back using the ggwave CLI utilities."
    ),
    version="0.1.0",
)


def _resolve_cli_path(value: str | None, default: Path) -> Path:
    """Resolve CLI paths, allowing relative values via environment variables."""
    if value:
        candidate = Path(value)
        if not candidate.is_absolute():
            candidate = PROJECT_ROOT / candidate
        return candidate
    return default


def _resolve_encoder_paths() -> tuple[Path, Path | None]:
    env_path = os.environ.get("GGWAVE_ENCODE")
    if env_path:
        return _resolve_cli_path(env_path, DEFAULT_ENCODE_PATH), None
    return DEFAULT_ENCODE_PATH, FALLBACK_ENCODE_PATH


def _resolve_decoder_path() -> Path:
    return _resolve_cli_path(os.environ.get("GGWAVE_DECODE"), DEFAULT_DECODE_PATH)


def _run_cli(command: Iterable[str], *, input_data: bytes | None = None) -> subprocess.CompletedProcess[bytes]:
    try:
        return subprocess.run(
            list(command),
            input=input_data,
            check=True,
            capture_output=True,
        )
    except FileNotFoundError as exc:  # pragma: no cover - file missing is handled as runtime error
        raise HTTPException(status_code=500, detail=f"Executable not found: {command!r}") from exc
    except subprocess.CalledProcessError as exc:
        stderr = (exc.stderr or b"").decode("utf-8", errors="ignore").strip()
        detail = stderr or f"Command '{' '.join(map(str, command))}' failed with exit code {exc.returncode}"
        raise HTTPException(status_code=500, detail=detail) from exc


def _remove_file(path: Path) -> None:
    try:
        path.unlink()
    except FileNotFoundError:
        pass


def _finalize_stream(file_obj, path: Path) -> None:
    try:
        file_obj.close()
    finally:
        _remove_file(path)


@app.post(
    "/encode",
    response_class=StreamingResponse,
    summary="Encode text into an ultrasonic WAV payload",
)
def encode(text: str = Query(..., description="Text to encode into a WAV file.")) -> StreamingResponse:
    if text == "":
        raise HTTPException(status_code=400, detail="Query parameter 'text' must not be empty.")

    encoder_path, fallback_path = _resolve_encoder_paths()
    input_payload = (text + "\n").encode("utf-8")

    with tempfile.NamedTemporaryFile(suffix=".wav", delete=False) as tmp_file:
        tmp_path = Path(tmp_file.name)

    try:
        if encoder_path.exists() and encoder_path.is_file():
            _run_cli([str(encoder_path), "-f", str(tmp_path)], input_data=input_payload)
        elif fallback_path and fallback_path.exists() and fallback_path.is_file():
            result = _run_cli([str(fallback_path)], input_data=input_payload)
            tmp_path.write_bytes(result.stdout)
        else:
            expected = encoder_path if fallback_path is None else DEFAULT_ENCODE_PATH
            hint = (
                "Set GGWAVE_ENCODE to the CLI path or run 'make build-ggwave' so the"
                f" binary is available at {expected}."
            )
            raise HTTPException(status_code=500, detail=hint)
    except Exception:
        _remove_file(tmp_path)
        raise

    wav_stream = tmp_path.open("rb")
    background = BackgroundTask(_finalize_stream, wav_stream, tmp_path)
    headers = {"Content-Disposition": 'attachment; filename="payload.wav"'}
    return StreamingResponse(wav_stream, media_type="audio/wav", background=background, headers=headers)


@app.post(
    "/decode",
    response_class=PlainTextResponse,
    summary="Decode an ultrasonic WAV payload into text",
)
async def decode(file: UploadFile = File(..., description="WAV file generated by ggwave.")) -> PlainTextResponse:
    contents = await file.read()
    if not contents:
        raise HTTPException(status_code=400, detail="Uploaded WAV file was empty.")

    decoder_path = _resolve_decoder_path()
    if not decoder_path.exists() or not decoder_path.is_file():
        raise HTTPException(
            status_code=500,
            detail=(
                "Decoder CLI not found. Set GGWAVE_DECODE or run 'make build-ggwave' so the"
                f" binary is available at {decoder_path}."
            ),
        )

    with tempfile.NamedTemporaryFile(suffix=".wav", delete=False) as tmp_file:
        tmp_file.write(contents)
        tmp_path = Path(tmp_file.name)

    try:
        result = _run_cli([str(decoder_path), str(tmp_path)])
    finally:
        _remove_file(tmp_path)

    decoded_output = result.stdout.decode("utf-8", errors="ignore")
    match = DECODE_PATTERN.search(decoded_output)
    if not match:
        raise HTTPException(
            status_code=400,
            detail="Could not decode a message from the provided audio.",
        )

    message = match.group(1)
    return PlainTextResponse(content=message)
